*Serial Collector -XX:+UseSerialGC
    Результат: 80 сборок - 228.623s до OOM
    Время STW GC при малом использовании памяти примерно 30мс,
    но при значении близком к ООМ, уже уходит больше времени на STW паузу - примерно 500мс
    Данный GC работает в один поток последовательно и блокирует работу всего приложения.

*Parallel Collector -XX:+UseParallelGC
    Результат- 78 сборок - 228.962s до OOM
    Результаты по времени до ООМ и количеству запусков GC схож с Serial Collector, с единственным отличием
    в паузах STW - они растут на протяжении работы с 6мс до 80мс
    Данный GC может работать параллельно в несколько потоков,
    но он так же как и однопоточный полностью отстанавливает работу приложения

*ZGC -XX:+UnlockExperimentalVMOptions -XX:+UseZGC
    Не удалось запустить на 11 java в косоли ошибка - Option -XX:+UseZGC not supported

*G1 -XX:+UseG1GC
    Результат: 100 сборок - 222.081s до OOM
    Разработан для работы с большими кучами >4gb, на данном тесте выигрывает за счет того,
    что STW происходит только на этапе маркирования.

*CMS -XX:+UseConcMarkSweepGC
    Доходит до опр. критичного остатка памяти, останавливая процесс и чистит память продолжительное время
    за 800 запусков и 10мин. времени OOM так и не выпал при работе с данным GC.
    Использует больше ЦП, чем другие тестируемы GC

Вывод: CMS, по моему мнению лучше остальных подходит для данного приложения и выделенной памяти в 512мб,
    скорость очистки настолько высока, что данный GC недопустил OOM за 10 минут времени.
    Все остальные конкуренты не продержались и четырёх минут.